--- src/graph/IntegratedGraph.java
+++ src/graph/IntegratedGraph.java
@@ -3,11 +3,16 @@ package graph;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
 import java.io.File; // Import the File class
 import java.io.FileNotFoundException; // Import this class to handle errors
-import java.lang.reflect.Array;
+import java.io.IOException;
 import java.util.Scanner; // Import the Scanner class to read text files
-import java.util.Stack;
+
+import javax.imageio.ImageIO;
+import javax.swing.JFileChooser;
+import javax.swing.JPanel;
 
 import org.graphstream.graph.*;
 import org.graphstream.graph.implementations.*;
@@ -15,11 +20,14 @@ import org.graphstream.graph.implementations.*;
 import event.LogEvent;
 
 public class IntegratedGraph extends SingleGraph {
+
 	private int hasPath = 0;
 	private int start = 0;
 	private int end = 0;
-	private static int[] D;
-	private static int[] L;
+	private int has_start = 0;
+	private int has_end = 0;
+	private static int[] visited;
+	private static int[] load_path;
 
 	public IntegratedGraph(String id, boolean strictChecking, boolean autoCreate, int initialNodeCapacity,
 			int initialEdgeCapacity) {
@@ -66,69 +75,111 @@ public class IntegratedGraph extends SingleGraph {
 
 		}
 		edges().forEach(s -> {
-//			System.out.print(s.getSourceNode().getId());
-			// System.out.print(" "+s.getTargetNode() + " ");
-//			String getedge = s.getId();
-			// arr[Integer.parseInt(s.getSourceNode().getId())][Integer.parseInt(s.getTargetNode().getId())]
-			// = 1;
 			arr[s.getSourceNode().getIndex()][s.getTargetNode().getIndex()] = 1;
 		});
 
-//		for (int i = 0; i < arr.length; i++) {
-//			for (int j = 0; j < arr.length; j++) {
-//				System.out.print(arr[i][j]);
-//			}
-//			System.out.println();
-//		}
-//		int start = 0;
-//		int end = 0;
 		nodes().forEach(s -> {
 			if (s.getId().equals(source)) {
 				start = s.getIndex();
+				has_start += 1;
 			}
 			if (s.getId().equals(destination)) {
 				end = s.getIndex();
+				has_end += 1;
 			}
 		});
-		D = new int[getNodeCount()];
-		L = new int[getNodeCount()];
-		for (int i = 0; i < getNodeCount(); i++) {
-			D[i] = 0;
-			L[i] = 0;
-		}
-		D[start] = 1;
-		L[0] = start;
-		checkPath(1, end, arr);
-		if (hasPath == 0) {
-			LogEvent.emitLogEvent(
-					new LogEvent(LogEvent.Cause.INFO, "No Path From " + getNode(start) + " to " + getNode(end)));
+		if (has_start == 0 || has_end == 0) {
+			if (has_start == 0) {
+				System.out.println("Start node has not found!");
+			}
+			if (has_end == 0) {
+				System.out.println("End node has not found!");
+			}
+		} else {
+			visited = new int[getNodeCount()];
+			load_path = new int[getNodeCount()];
+			for (int i = 0; i < getNodeCount(); i++) {
+				visited[i] = 0;
+				load_path[i] = 0;
+			}
+			visited[start] = 1;
+			load_path[0] = start;
+			checkPath(1, end, arr, paths);
+//		for (Iterator iterator = paths.iterator(); iterator.hasNext();) {
+//			List<Edge> list = (List<Edge>) iterator.next();
+//			for (Iterator iterator2 = list.iterator(); iterator2.hasNext();) {
+//				Edge edge = (Edge) iterator2.next();
+//				System.out.println(edge.getId());
+//			}
+//		}
 		}
 		return paths;
 	}
 
-	public void checkPath(int number_edge, int end, int[][] arr) {
-		if (L[number_edge - 1] == end) {
+	public void checkPath(int number_edge, int end, int[][] arr, List<List<Edge>> paths) {
+		if (load_path[number_edge - 1] == end) {
 			hasPath++;
-			String msg = "Path:" + getNode(L[0]);
-			for (int i = 1; i < number_edge; ++i)
-				msg += "->" + getNode(L[i]);
-			LogEvent.emitLogEvent(new LogEvent(LogEvent.Cause.INFO, msg));
+			List<Edge> path = new ArrayList<Edge>();
+			for (int i = 1; i < number_edge; ++i) {
+				Edge edge = getNode(load_path[i - 1]).getEdgeBetween(getNode(load_path[i]));
+				path.add(edge);
+			}
+			paths.add(path);
 		} else {
 			for (int i = 0; i < getNodeCount(); ++i) {
-				if (arr[L[number_edge - 1]][i] != 0 && D[i] == 0) {
-					L[number_edge] = i;
-					D[i] = 1;
-					checkPath(number_edge + 1, end, arr);
-					L[number_edge] = 0;
-					D[i] = 0;
+				if (arr[load_path[number_edge - 1]][i] != 0 && visited[i] == 0) {
+					load_path[number_edge] = i;
+					visited[i] = 1;
+					checkPath(number_edge + 1, end, arr, paths);
+					load_path[number_edge] = 0;
+					visited[i] = 0;
 				}
 			}
 		}
 	}
 
-	public void toImage(String name) {
-		// TODO
+	public void exportImg(JPanel view) throws IOException {
+
+		final JFileChooser fileChooser = new JFileChooser();
+		fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
+		fileChooser.setCurrentDirectory(new File(System.getProperty("user.dir")));
+
+		int result = fileChooser.showSaveDialog(fileChooser);
+		if (result == JFileChooser.APPROVE_OPTION) {
+			File selectedFile = fileChooser.getSelectedFile();
+			BufferedImage image = new BufferedImage(view.getSize().width, view.getSize().height,
+					BufferedImage.TYPE_INT_RGB);
+			Graphics2D g2 = image.createGraphics();
+			view.paint(g2);
+			try {
+				ImageIO.write(image, "png", new File(selectedFile.getAbsolutePath() + ".png"));
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	public void findPath() {
+		// TODO Auto-generated method stub
 
 	}
 
+	public void choise_path(int index, String source, String destination, int choise) {
+		int move = 0;
+		List<List<Edge>> pathList = findAllPath(source, destination);
+		List<Edge> path = new ArrayList<Edge>();
+		if (index > pathList.size() - 1) {
+			System.out.println("Path invalid");
+		} else {
+			path = pathList.get(index);
+			while (move < path.size()) {
+				System.out.println(path.get(move).getId());
+				move += choise;
+				if (move >= path.size() || move < 0) {
+					System.out.println("You shall not pass");
+				}
+			}
+		}
+	}
+
 }
